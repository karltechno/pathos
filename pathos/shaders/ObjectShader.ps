#include "shaderlib/ShaderOutput.hlsli"
#include "shaderlib/GlobalSamplers.hlsli"
#include "shaderlib/LightingCommon.hlsli"
#include "shaderlib/CommonShared.h"

Texture2D<float4> g_albedo : register(t0, space0);
Texture2D<float4> g_normal : register(t1, space0);
Texture2D<float4> g_metalRoughness : register(t2, space0);
Texture2D<float4> g_ao : register(t3, space0);

TextureCube<float4> g_irrad : register(t0, space1);
TextureCube<float4> g_ggxEnv : register(t1, space1);
Texture2D<float4> g_ggxLut : register(t2, space1);
StructuredBuffer<LightData> g_lights : register(t3, space1);
Texture2DArray<float> g_shadowCascades : register(t4, space1);
StructuredBuffer<MaterialData> g_materials : register(t5, space1);

ConstantBuffer<BatchConstants> g_batch : register(b0, space0); 
ConstantBuffer<FrameConstants> g_frame : register(b0, space1);

static const float3 c_cascadeCols[4] = 
{
    float3(1, 0, 0),
    float3(0, 1, 0),
    float3(0, 0, 1),
    float3(1, 1, 0)
};


void SelectCascade(float3 _world, float _viewZ, out float _cascade, out float3 _lightSpace)
{
    // Branchless cascade selection (assuming 4 csm)
    float4 weights = _viewZ < g_frame.cascadeSplits;
    weights.yzw -= weights.xyz;
    _cascade = dot(weights, float4(0, 1, 2, 3));
    float4 coord = mul(float4(_world, 1.), g_frame.cascadeMatrices[_cascade]);

    _lightSpace = coord.xyz / coord.w;
}

float ComputeDirectionalShadow(float3 _world, float _viewZ, float3 _surfNorm, float3 _sunDir)
{
    float cascade;
    float3 shadowPos;
    SelectCascade(_world, _viewZ, cascade, shadowPos);

    return g_shadowCascades.SampleCmp(g_samplerCmp, float3(shadowPos.xy, cascade), shadowPos.z);
}

float4 main(in VSOut_ObjectFull _input) : SV_Target
{
    float3 normal = normalize(_input.normal);
    float3 tangent = normalize(_input.tangentSign.xyz);
    float3x3 tbn = float3x3(tangent, ReconstructBitangent(normal, _input.tangentSign), normal);

    float3 color = float3(0.0, 0.0, 0.0);

    float3 view = normalize(g_frame.camPos - _input.posWS); 

    MaterialData materialData = g_materials[g_batch.materialIdx];

    float3 metalRough = g_metalRoughness.Sample(g_samplerAnisoWrap, _input.uv).xyz;
    float3 normalTex = normalize(g_normal.Sample(g_samplerAnisoWrap, _input.uv).xyz * 2.0 - 1.0);
    normalTex = mul(normalTex, tbn);


    float roughness = metalRough.g * materialData.roughness;
    float metallic = metalRough.b * materialData.metalness;
    float3 baseCol = g_albedo.Sample(g_samplerAnisoWrap, _input.uv).xyz * materialData.baseColour.xyz;

    SurfaceData surf = CreateSurfaceData(normalTex, _input.posWS, metallic, roughness, baseCol);

    for(uint i = 0; i < g_frame.numLights; ++i)
    {
        LightData light = g_lights[i];
        color += ComputeLighting_Point(light, surf, view);
    }

    float dirShadow = ComputeDirectionalShadow(_input.posWS, _input.viewDepth, normal, g_frame.sunDir);
    color += ComputeLighting_Common(g_frame.sunColor, surf, -g_frame.sunDir, view) * dirShadow;
    
    float3 irrad = g_irrad.Sample(g_samplerLinearWrap, surf.norm).xyz;

    uint w,h,levels;
    g_ggxEnv.GetDimensions(0, w, h, levels);
    color += ComputeLighting_IBL(surf, view, irrad, g_ggxEnv, levels, g_ggxLut);
    

    // float3 ao = g_ao.Sample(g_samplerLinearWrap, _input.uv).xyz;
    return float4(color, 1);
}   